{"version":3,"file":"format_worker.bundle.js","mappings":"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","sources":["webpack://apple2js/./js/util.ts","webpack://apple2js/./js/base64.ts","webpack://apple2js/./js/formats/types.ts","webpack://apple2js/./js/formats/format_utils.ts","webpack://apple2js/./js/formats/do.ts","webpack://apple2js/./js/formats/nib.ts","webpack://apple2js/./js/formats/po.ts","webpack://apple2js/./js/formats/2mg.ts","webpack://apple2js/./js/formats/woz.ts","webpack://apple2js/./js/formats/create_disk.ts","webpack://apple2js/./js/formats/d13.ts","webpack://apple2js/./workers/format.worker.ts","webpack://apple2js/./js/types.ts"],"sourcesContent":["import { byte, memory, word } from './types';\n\n/*eslint no-console: 0*/\n\nconst hex_digits = '0123456789ABCDEF';\nconst bin_digits = '01';\n\n/** Returns a random byte. */\nexport function garbage(): byte {\n    return (Math.random() * 0x100) & 0xff;\n}\n\nexport const testables = {\n    garbage\n};\n\n/**\n * Returns an array or Uint8Array of `size` bytes filled as if the computer\n * was just powered on.\n */\nexport function allocMem(size: number) {\n    const result = new Uint8Array(size);\n\n    for (let idx = 0; idx < size; idx++) {\n        result[idx] = (idx & 0x02) ? 0x00 : 0xff;\n    }\n    // Borrowed from AppleWin (https://github.com/AppleWin/AppleWin)\n    for (let idx = 0; idx < size; idx += 0x200) {\n        result[idx + 0x28] = garbage();\n        result[idx + 0x29] = garbage();\n        result[idx + 0x68] = garbage();\n        result[idx + 0x69] = garbage();\n    }\n    return result;\n}\n\n/** Returns an array or Uint8Array of 256 * `pages` bytes. */\nexport function allocMemPages(pages: number): memory {\n    return allocMem(pages << 8);\n}\n\n/** Returns a new Uint8Array for the input array. */\nexport function bytify(ary: number[]): memory {\n    return new Uint8Array(ary);\n}\n\n/** Returns a new Uint8Array with the concatenated data from the inputs. */\nexport function concat(...arys: Array<byte[] | Uint8Array>) {\n    const result = new Uint8Array(arys.reduce((l, ary) => l + ary.length, 0));\n    let offset = 0;\n    for (let i = 0; i < arys.length; i++) {\n        result.set(arys[i], offset);\n        offset += arys[i].length;\n    }\n    return result;\n}\n\n/** Writes to the console. */\nexport function debug(...args: unknown[]): void {\n    console.log(...args);\n}\n\n/**\n * Returns a string of hex digits (all caps).\n * @param v the value to encode\n * @param n the number of nibbles. If `n` is missing, it is guessed from the value\n *     of `v`. If `v` < 256, it is assumed to be 2 nibbles, otherwise 4.\n */\nexport function toHex(v: byte | word | number, n?: number) {\n    if (!n) {\n        n = v < 256 ? 2 : 4;\n    }\n    let result = '';\n    for (let idx = 0; idx < n; idx++) {\n        result = hex_digits[v & 0x0f] + result;\n        v >>= 4;\n    }\n    return result;\n}\n\n/**\n * Returns a string of 8 binary digits.\n * @param v the value to encode\n */\nexport function toBinary(v: byte) {\n    let result = '';\n    for (let idx = 0; idx < 8; idx++) {\n        result = bin_digits[v & 0x01] + result;\n        v >>= 1;\n    }\n    return result;\n}\n","import { memory } from './types';\n\nconst B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/** Encode an array of bytes in base64. */\nexport function base64_encode(data: null | undefined): undefined;\nexport function base64_encode(data: memory): string;\nexport function base64_encode(data: memory | null | undefined): string | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Bayron Guevara\n    // +   improved by: Thunder.m\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_encode\n    // *     example 1: base64_encode('Kevin van Zonneveld');\n    // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['atob'] == 'function') {\n    //    return atob(data);\n    //}\n\n\n    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc='';\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do { // pack three octets into four hexets\n        o1 = data[i++];\n        o2 = data[i++];\n        o3 = data[i++];\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = B64.charAt(h1) + B64.charAt(h2) + B64.charAt(h3) + B64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n}\n\n/** Returns undefined if the input is null or undefined. */\nexport function base64_decode(data: null | undefined): undefined;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(data: string): memory;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(data: string | null | undefined): memory | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Thunder.m\n    // +      input by: Aman Gupta\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Onno Marsman\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +      input by: Brett Zamir (http://brett-zamir.me)\n    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_decode\n    // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n    // *     returns 1: 'Kevin van Zonneveld'\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['btoa'] == 'function') {\n    //    return btoa(data);\n    //}\n\n    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0;\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do {  // unpack four hexets into three octets using index points in B64\n        h1 = B64.indexOf(data.charAt(i++));\n        h2 = B64.indexOf(data.charAt(i++));\n        h3 = B64.indexOf(data.charAt(i++));\n        h4 = B64.indexOf(data.charAt(i++));\n\n        bits = h1<<18 | h2<<12 | h3<<6 | h4;\n\n        o1 = bits>>16 & 0xff;\n        o2 = bits>>8 & 0xff;\n        o3 = bits & 0xff;\n\n        tmp_arr[ac++] = o1;\n        if (h3 !== 64) {\n            tmp_arr[ac++] = o2;\n        }\n        if (h4 !== 64) {\n            tmp_arr[ac++] = o3;\n        }\n    } while (i < data.length);\n\n    return new Uint8Array(tmp_arr);\n}\n\nconst DATA_URL_PREFIX = 'data:application/octet-stream;base64,';\n\nexport function base64_json_parse(json: string): unknown {\n    const reviver = (_key: string, value: unknown) => {\n        if (typeof value ==='string' && value.startsWith(DATA_URL_PREFIX)) {\n            return base64_decode(value.slice(DATA_URL_PREFIX.length));\n        }\n        return value;\n    };\n\n    return JSON.parse(json, reviver);\n}\n\nexport function base64_json_stringify(json: unknown) {\n    const replacer = (_key: string, value: unknown) => {\n        if (value instanceof Uint8Array) {\n            return DATA_URL_PREFIX + base64_encode(value);\n        }\n        return value;\n    };\n\n    return JSON.stringify(json, replacer);\n}\n","import type { byte, memory, MemberOf, word } from '../types';\nimport type { GamepadConfiguration } from '../ui/types';\nimport { InfoChunk } from './woz';\n\nexport const SUPPORTED_SECTORS = [13, 16] as const;\nexport type SupportedSectors = MemberOf<typeof SUPPORTED_SECTORS>;\n\nexport const DRIVE_NUMBERS = [1, 2] as const;\nexport type DriveNumber = MemberOf<typeof DRIVE_NUMBERS>;\n\n/**\n * Arguments for the disk format processors.\n */\nexport interface DiskOptions {\n    name: string;\n    side?: string | undefined;\n    volume: byte;\n    readOnly: boolean;\n    data?: memory[][];\n    rawData?: ArrayBuffer;\n    blockVolume?: boolean;\n}\n\n/**\n * JSON file entry format\n */\nexport interface DiskDescriptor {\n    name: string;\n    disk?: number;\n    filename: string;\n    e?: boolean;\n    category: string;\n}\n\n/**\n * JSON binary image (not used?)\n */\nexport interface JSONBinaryImage {\n    type: 'binary';\n    start: word;\n    length: word;\n    data: byte[];\n    gamepad?: GamepadConfiguration;\n}\n\n/**\n * Information about a disk image not directly related to the\n * disk contents. For example, the name or even a scan of the\n * disk label are \"metadata\", but the volume number is not.\n */\nexport interface DiskMetadata {\n    /** Displayed disk name */\n    name: string;\n    /** (Optional) Disk side (Front/Back, A/B) */\n    side?: string | undefined;\n}\n\n/**\n * Return value from disk format processors. Describes raw disk\n * data which the DiskII card can process.\n */\nexport interface Disk {\n    metadata: DiskMetadata;\n    readOnly: boolean;\n}\n\nexport const NO_DISK = 'empty';\nexport const ENCODING_NIBBLE = 'nibble';\nexport const ENCODING_BITSTREAM = 'bitstream';\nexport const ENCODING_BLOCK = 'block';\n\nexport interface FloppyDisk extends Disk {\n    encoding: typeof ENCODING_NIBBLE | typeof ENCODING_BITSTREAM | typeof NO_DISK;\n}\n\nexport interface NoFloppyDisk extends FloppyDisk {\n    encoding: typeof NO_DISK;\n}\n\nexport interface NibbleDisk extends FloppyDisk {\n    encoding: typeof ENCODING_NIBBLE;\n    format: Exclude<NibbleFormat, 'woz'>;\n    volume: byte;\n    tracks: memory[];\n}\n\nexport interface WozDisk extends FloppyDisk {\n    encoding: typeof ENCODING_BITSTREAM;\n    format: 'woz';\n    trackMap: number[];\n    rawTracks: Uint8Array[];\n    info: InfoChunk | undefined;\n}\n\nexport interface BlockDisk extends Disk {\n    encoding: typeof ENCODING_BLOCK;\n    format: BlockFormat;\n    blocks: Uint8Array[];\n}\n\n/**\n * File types supported by floppy devices in nibble mode.\n */\nexport const NIBBLE_FORMATS = [\n    '2mg',\n    'd13',\n    'do',\n    'dsk',\n    'po',\n    'nib',\n] as const;\n\n/**\n * File types supported by floppy devices in bitstream mode.\n */\nexport const BITSTREAM_FORMATS = [\n    'woz',\n] as const;\n\n/**\n * All file types supported by floppy devices.\n */\nexport const FLOPPY_FORMATS = [\n    ...NIBBLE_FORMATS,\n    ...BITSTREAM_FORMATS,\n] as const;\n\n/**\n * File types supported by block devices.\n */\nexport const BLOCK_FORMATS = [\n    '2mg',\n    'hdv',\n    'po',\n] as const;\n\n/**\n * All supported disk formats.\n */\nexport const DISK_FORMATS = [\n    ...FLOPPY_FORMATS,\n    ...BLOCK_FORMATS,\n] as const;\n\nexport type FloppyFormat = MemberOf<typeof FLOPPY_FORMATS>;\nexport type NibbleFormat = MemberOf<typeof NIBBLE_FORMATS>;\nexport type BitstreamFormat = 'woz';\nexport type BlockFormat = MemberOf<typeof BLOCK_FORMATS>;\nexport type DiskFormat = MemberOf<typeof DISK_FORMATS>;\n\n/** Type guard for nibble disk formats. */\nexport function isNibbleDiskFormat(f: DiskFormat): f is NibbleFormat {\n    return NIBBLE_FORMATS.includes(f as NibbleFormat);\n}\n\n/** Type guard for block disk formats. */\nexport function isBlockDiskFormat(f: DiskFormat): f is BlockFormat {\n    return BLOCK_FORMATS.includes(f as BlockFormat);\n}\n\nexport function isNoFloppyDisk(disk: Disk): disk is NoFloppyDisk {\n    return (disk as NoFloppyDisk)?.encoding === NO_DISK;\n}\n\n/** Type guard for NibbleDisks */\nexport function isNibbleDisk(disk: Disk): disk is NibbleDisk {\n    return (disk as NibbleDisk)?.encoding === ENCODING_NIBBLE;\n}\n\n/** Type guard for NibbleDisks */\nexport function isWozDisk(disk: Disk): disk is WozDisk {\n    return (disk as WozDisk)?.encoding === ENCODING_BITSTREAM;\n}\n\n/**\n * Base format for JSON defined disks\n */\n\nexport class JSONDiskBase {\n    type: DiskFormat;\n    name: string;\n    disk?: string;\n    category?: string;\n    volume?: byte;\n    readOnly?: boolean;\n    gamepad?: GamepadConfiguration;\n}\n\n/**\n * JSON Disk format with base64 encoded tracks with sectors\n */\n\nexport interface Base64JSONDisk extends JSONDiskBase {\n    type: Exclude<DiskFormat, 'nib'>;\n    encoding: 'base64';\n    data: string[][];\n}\n\n/**\n * JSON Disk format with base64 encoded nibblized tracks\n */\n\nexport interface Base64JSONNibbleDisk extends JSONDiskBase {\n    type: 'nib';\n    encoding: 'base64';\n    data: string[];\n}\n\n/**\n * JSON Disk format with byte array tracks\n */\n\nexport interface BinaryJSONDisk extends JSONDiskBase {\n    type: DiskFormat;\n    encoding: 'binary';\n    data: memory[][];\n}\n\n/**\n * General JSON Disk format\n */\n\nexport type JSONDisk = Base64JSONDisk | Base64JSONNibbleDisk | BinaryJSONDisk;\n\n/**\n * Process Disk message payloads for worker\n */\n\nexport const PROCESS_BINARY = 'PROCESS_BINARY';\nexport const PROCESS_JSON_DISK = 'PROCESS_JSON_DISK';\nexport const PROCESS_JSON = 'PROCESS_JSON';\n\n/** Binary disk file message */\nexport interface ProcessBinaryMessage {\n    type: typeof PROCESS_BINARY;\n    payload: {\n        driveNo: DriveNumber;\n        fmt: FloppyFormat;\n        options: DiskOptions;\n    };\n}\n\n/** Processed JSON file message (used for localStorage) */\nexport interface ProcessJsonDiskMessage {\n    type: typeof PROCESS_JSON_DISK;\n    payload: {\n        driveNo: DriveNumber;\n        jsonDisk: JSONDisk;\n    };\n}\n\n/** Raw JSON file message */\nexport interface ProcessJsonMessage {\n    type: typeof PROCESS_JSON;\n    payload: {\n        driveNo: DriveNumber;\n        json: string;\n    };\n}\n\nexport type FormatWorkerMessage =\n    ProcessBinaryMessage |\n    ProcessJsonDiskMessage |\n    ProcessJsonMessage;\n\n/**\n * Format work result message type\n */\n\nexport const DISK_PROCESSED = 'DISK_PROCESSED';\n\nexport interface DiskProcessedResponse {\n    type: typeof DISK_PROCESSED;\n    payload: {\n        driveNo: DriveNumber;\n        disk: FloppyDisk | null;\n    };\n}\n\nexport type FormatWorkerResponse =\n    DiskProcessedResponse;\n\nexport interface MassStorageData {\n    metadata: DiskMetadata;\n    ext: DiskFormat;\n    readOnly: boolean;\n    volume?: byte;\n    data: ArrayBuffer;\n}\n\n/**\n * Block device common interface\n */\nexport interface MassStorage<T> {\n    setBinary(drive: number, name: string, ext: T, data: ArrayBuffer): boolean;\n    getBinary(drive: number, ext?: T): MassStorageData | null;\n}\n","import { bit, byte, memory } from '../types';\nimport { base64_decode, base64_encode } from '../base64';\nimport { bytify, debug, toHex } from '../util';\nimport { NibbleDisk, ENCODING_NIBBLE, JSONDisk, isNibbleDiskFormat, SupportedSectors } from './types';\n\n/**\n * DOS 3.3 Physical sector order (index is physical sector, value is DOS sector).\n */\nexport const DO = [\n    0x0, 0x7, 0xE, 0x6, 0xD, 0x5, 0xC, 0x4,\n    0xB, 0x3, 0xA, 0x2, 0x9, 0x1, 0x8, 0xF\n] as const;\n\n/**\n * DOS 3.3 Logical sector order (index is DOS sector, value is physical sector).\n */\nexport const _DO = [\n    0x0, 0xD, 0xB, 0x9, 0x7, 0x5, 0x3, 0x1,\n    0xE, 0xC, 0xA, 0x8, 0x6, 0x4, 0x2, 0xF\n] as const;\n\n/**\n * ProDOS Physical sector order (index is physical sector, value is ProDOS sector).\n */\nexport const PO = [\n    0x0, 0x8, 0x1, 0x9, 0x2, 0xa, 0x3, 0xb,\n    0x4, 0xc, 0x5, 0xd, 0x6, 0xe, 0x7, 0xf\n] as const;\n\n/**\n * ProDOS Logical sector order (index is ProDOS sector, value is physical sector).\n */\nexport const _PO = [\n    0x0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe,\n    0x1, 0x3, 0x5, 0x7, 0x9, 0xb, 0xd, 0xf\n] as const;\n\n/**\n * DOS 13-sector disk physical sector order (index is disk sector, value is\n * physical sector).\n */\nexport const D13O = [\n    0x0, 0xa, 0x7, 0x4, 0x1, 0xb, 0x8, 0x5, 0x2, 0xc, 0x9, 0x6, 0x3\n] as const;\n\nexport const _D13O = [\n    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc\n] as const;\n\nconst TRANS53 = [\n    0xab, 0xad, 0xae, 0xaf, 0xb5, 0xb6, 0xb7, 0xba,\n    0xbb, 0xbd, 0xbe, 0xbf, 0xd6, 0xd7, 0xda, 0xdb,\n    0xdd, 0xde, 0xdf, 0xea, 0xeb, 0xed, 0xee, 0xef,\n    0xf5, 0xf6, 0xf7, 0xfa, 0xfb, 0xfd, 0xfe, 0xff\n] as const;\n\nexport const DETRANS53 = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // A0\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, // A8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, // B0\n    0x00, 0x00, 0x07, 0x08, 0x00, 0x09, 0x0A, 0x0B, // B8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // C0\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // C8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0D, // D0\n    0x00, 0x00, 0x0E, 0x0F, 0x00, 0x10, 0x11, 0x12, // D8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // E0\n    0x00, 0x00, 0x13, 0x14, 0x00, 0x15, 0x16, 0x17, // E8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x19, 0x1A, // F0\n    0x00, 0x00, 0x1B, 0x1C, 0x00, 0x1D, 0x1E, 0x1F, // F8\n] as const;\n\nconst TRANS62 = [\n    0x96, 0x97, 0x9a, 0x9b, 0x9d, 0x9e, 0x9f, 0xa6,\n    0xa7, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbc,\n    0xbd, 0xbe, 0xbf, 0xcb, 0xcd, 0xce, 0xcf, 0xd3,\n    0xd6, 0xd7, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,\n    0xdf, 0xe5, 0xe6, 0xe7, 0xe9, 0xea, 0xeb, 0xec,\n    0xed, 0xee, 0xef, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,\n    0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff\n] as const;\n\nexport const DETRANS62 = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n    0x00, 0x00, 0x02, 0x03, 0x00, 0x04, 0x05, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08,\n    0x00, 0x00, 0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,\n    0x00, 0x00, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,\n    0x00, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x1B, 0x00, 0x1C, 0x1D, 0x1E,\n    0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x20, 0x21,\n    0x00, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x2A, 0x2B,\n    0x00, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n    0x00, 0x00, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n    0x00, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F\n] as const;\n\n/**\n * Converts a byte into its 4x4 encoded representation\n *\n * @param val byte to encode.\n * @returns A two byte array of representing the 4x4 encoding.\n */\nexport function fourXfour(val: byte): [xx: byte, yy: byte] {\n    let xx = val & 0xaa;\n    let yy = val & 0x55;\n\n    xx >>= 1;\n    xx |= 0xaa;\n    yy |= 0xaa;\n\n    return [xx, yy];\n}\n\n/**\n * Converts 2 4x4 encoded bytes into a byte value\n *\n * @param xx First encoded byte.\n * @param yy Second encoded byte.\n * @returns The decoded value.\n */\nexport function defourXfour(xx: byte, yy: byte): byte {\n    return ((xx << 1) | 0x01) & yy;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into a\n * nibblized 16 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector16(volume: byte, track: byte, sector: byte, data: memory): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0) // Gap 1\n        gap = 0x80;\n    else { // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0x96]); // Address Prolog D5 AA 96\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles: byte[] = [];\n    const ptr2 = 0;\n    const ptr6 = 0x56;\n\n    for (let idx = 0; idx < 0x156; idx++) {\n        nibbles[idx] = 0;\n    }\n\n    let idx2 = 0x55;\n    for (let idx6 = 0x101; idx6 >= 0; idx6--) {\n        let val6 = data[idx6 % 0x100];\n        let val2: byte = nibbles[ptr2 + idx2];\n\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n\n        nibbles[ptr6 + idx6] = val6;\n        nibbles[ptr2 + idx2] = val2;\n\n        if (--idx2 < 0)\n            idx2 = 0x55;\n    }\n\n    let last = 0;\n    for (let idx = 0; idx < 0x156; idx++) {\n        const val = nibbles[idx];\n        buf.push(TRANS62[last ^ val]);\n        last = val;\n    }\n    buf.push(TRANS62[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into\n * a nibblized 13 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector13(volume: byte, track: byte, sector: byte, data: memory): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0) // Gap 1\n        gap = 0x80;\n    else { // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0xb5]); // Address Prolog D5 AA B5\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles = [];\n\n    let jdx = 0;\n    for (let idx = 0x32; idx >= 0; idx--) {\n        const a5 = data[jdx] >> 3;\n        const a3 = data[jdx] & 0x07;\n        jdx++;\n        const b5 = data[jdx] >> 3;\n        const b3 = data[jdx] & 0x07;\n        jdx++;\n        const c5 = data[jdx] >> 3;\n        const c3 = data[jdx] & 0x07;\n        jdx++;\n        const d5 = data[jdx] >> 3;\n        const d3 = data[jdx] & 0x07;\n        jdx++;\n        const e5 = data[jdx] >> 3;\n        const e3 = data[jdx] & 0x07;\n        jdx++;\n        nibbles[idx + 0x00] = a5;\n        nibbles[idx + 0x33] = b5;\n        nibbles[idx + 0x66] = c5;\n        nibbles[idx + 0x99] = d5;\n        nibbles[idx + 0xcc] = e5;\n        nibbles[idx + 0x100] = a3 << 2 | (d3 & 0x4) >> 1 | (e3 & 0x4) >> 2;\n        nibbles[idx + 0x133] = b3 << 2 | (d3 & 0x2) | (e3 & 0x2) >> 1;\n        nibbles[idx + 0x166] = c3 << 2 | (d3 & 0x1) << 1 | (e3 & 0x1);\n    }\n    nibbles[0xff] = data[jdx] >> 3;\n    nibbles[0x199] = data[jdx] & 0x07;\n\n    let last = 0;\n    for (let idx = 0x199; idx >= 0x100; idx--) {\n        const val = nibbles[idx];\n        buf.push(TRANS53[last ^ val]);\n        last = val;\n    }\n    for (let idx = 0x0; idx < 0x100; idx++) {\n        const val = nibbles[idx];\n        buf.push(TRANS53[last ^ val]);\n        last = val;\n    }\n    buf.push(TRANS53[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\nexport interface TrackNibble {\n    track: byte;\n    sector: byte;\n    nibble: byte;\n    sectors: SupportedSectors;\n}\n\nenum LookingFor {\n    START_OF_FIELD_MARKER_FIRST_NIBBLE,\n    START_OF_FIELD_MARKER_SECOND_NIBBLE,\n    FIELD_TYPE_MARKER,\n    ADDRESS_FIELD,\n    ADDRESS_FIELD_13,\n    DATA_FIELD_6AND2,\n    DATA_FIELD_5AND3,\n}\n\nexport class FindSectorError extends Error {\n    constructor(track: byte, sector: byte, e: unknown | Error | string) {\n        super(`Error finding track ${track} (${toHex(track)}), sector ${sector} (${toHex(sector)}): `\n            + (e instanceof Error\n                ? `${e.message}`\n                : `${String(e)}`));\n    }\n}\n\n/**\n * Finds a sector of data from a nibblized disk. The sector given should be the\n * \"physical\" sector number, meaning the one that appears in the address field.\n * The first sector with the right sector number and data whose checksum matches\n * is returned. This means that for a dual-boot disk (DOS 3.2 and DOS 3.3),\n * whichever sector is found first wins.\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns the track, sector, nibble offset, and detected sectors\n */\nexport function findSector(disk: NibbleDisk, track: byte, sector: byte): TrackNibble {\n    const cur = disk.tracks[track];\n    let sectors: SupportedSectors = 16;\n    let state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n    let idx = 0;\n    let retry = 0;\n\n    function _readNext() {\n        const result = cur[idx++];\n        if (idx >= cur.length) {\n            idx = 0;\n            retry++;\n        }\n        return result;\n    }\n    function _skipBytes(count: number) {\n        idx += count;\n        if (idx >= cur.length) {\n            idx %= cur.length;\n            retry++;\n        }\n    }\n    let t = 0, s = 0, v = 0, checkSum;\n    while (retry < 4) {\n        let val: byte;\n        switch (state) {\n            case LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE:\n                val = _readNext();\n                state = (val === 0xd5)\n                    ? LookingFor.START_OF_FIELD_MARKER_SECOND_NIBBLE\n                    : LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.START_OF_FIELD_MARKER_SECOND_NIBBLE:\n                val = _readNext();\n                state = (val === 0xaa)\n                    ? LookingFor.FIELD_TYPE_MARKER\n                    : LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.FIELD_TYPE_MARKER:\n                val = _readNext();\n                switch (val) {\n                    case 0x96:\n                        state = LookingFor.ADDRESS_FIELD;\n                        sectors = 16;\n                        break;\n                    case 0xB5:\n                        state = LookingFor.ADDRESS_FIELD;\n                        sectors = 13;\n                        break;\n                    case 0xAD:\n                        state = sectors === 16 ? LookingFor.DATA_FIELD_6AND2 : LookingFor.DATA_FIELD_5AND3;\n                        break;\n                    default:\n                        state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                }\n                break;\n            case LookingFor.ADDRESS_FIELD:\n                v = defourXfour(_readNext(), _readNext()); // Volume\n                t = defourXfour(_readNext(), _readNext()); // Track\n                s = defourXfour(_readNext(), _readNext()); // Sector\n                checkSum = defourXfour(_readNext(), _readNext());\n                if (checkSum !== (v ^ t ^ s)) {\n                    debug('Invalid header checksum:', toHex(v), toHex(t), toHex(s), toHex(checkSum));\n                }\n                _skipBytes(3); // Skip footer\n                state = 0;\n                break;\n            case LookingFor.DATA_FIELD_6AND2:\n                if (s === sector && t === track) {\n                    // Save start of data\n                    const nibble = idx;\n\n                    // Do checksum on data\n                    let last = 0;\n                    for (let jdx = 0; jdx < 0x156; jdx++) {\n                        last = DETRANS62[_readNext() - 0x80] ^ last;\n                    }\n                    const checkSum = DETRANS62[_readNext() - 0x80] ^ last;\n                    // Validate checksum before returning\n                    if (!checkSum) {\n                        return { track, sector, nibble, sectors };\n                    } else {\n                        debug('Invalid data checksum:', toHex(last), toHex(track), toHex(sector), toHex(checkSum));\n                    }\n                    _skipBytes(3); // Skip footer\n                }\n                else\n                    _skipBytes(0x159); // Skip data, checksum and footer\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.DATA_FIELD_5AND3:\n                if (s === sector && t === track) {\n                    // Save start of data\n                    const nibble = idx;\n\n                    // Do checksum on data\n                    let last = 0;\n                    for (let jdx = 0; jdx < 0x19A; jdx++) {\n                        last = DETRANS53[_readNext() - 0xA0] ^ last;\n                    }\n                    const checkSum = DETRANS53[_readNext() - 0xA0] ^ last;\n                    // Validate checksum before returning\n                    if (!checkSum) {\n                        return { track, sector, nibble, sectors };\n                    } else {\n                        debug('Invalid data checksum:', toHex(last), toHex(track), toHex(sector), toHex(checkSum));\n                    }\n                    _skipBytes(3); // Skip footer\n                }\n                else {\n                    _skipBytes(0x19A); // Skip data, checksum and footer\n                }\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            default:\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n        }\n    }\n    throw new FindSectorError(track, sector, `too many retries (${retry})`);\n}\n\nexport class InvalidChecksum extends Error {\n    constructor(expected: byte, received: byte) {\n        super(`Expected: ${toHex(expected)}, received: ${toHex(received)}`);\n    }\n}\n\nexport class ReadSectorError extends Error {\n    constructor(track: byte, sector: byte, e: unknown | Error) {\n        super(`Error reading track ${track} (${toHex(track)}), sector ${sector} (${toHex(sector)}): `\n            + (e instanceof Error\n                ? `${e.message}`\n                : `${String(e)}`));\n    }\n}\n\n/**\n * Reads a sector of data from a nibblized disk. The sector given should be the\n * \"physical\" sector number, meaning the one that appears in the address field. \n * Like `findSector`, the first sector with the right sector number and data\n * whose checksum matches is returned. This means that for a dual-boot disk\n * (DOS 3.2 and DOS 3.3), whichever sector is found first wins.\n *\n * This does not work for WOZ disks.\n * \n * If the given track and sector combination is not found, a `ReadSectorError`\n * will be thrown.\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns An array of sector data bytes.\n */\nexport function readSector(disk: NibbleDisk, track: byte, sector: byte): Uint8Array {\n    const trackNibble = findSector(disk, track, sector);\n    const { nibble, sectors } = trackNibble;\n    const cur = disk.tracks[track];\n\n    let idx = nibble;\n    const _readNext = () => {\n        const result = cur[idx++];\n        if (idx >= cur.length) {\n            idx = 0;\n        }\n        return result;\n    };\n\n    try {\n        return sectors === 13 ? readSector13(_readNext) : readSector16(_readNext);\n    } catch (e: unknown) {\n        throw new ReadSectorError(track, sector, e);\n    }\n}\n\nfunction readSector16(_readNext: () => byte): Uint8Array {\n    const data = new Uint8Array(256);\n    const data2 = [];\n    let last: byte = 0;\n    let val;\n\n    for (let jdx = 0x55; jdx >= 0; jdx--) {\n        val = DETRANS62[_readNext() - 0x80] ^ last;\n        data2[jdx] = val;\n        last = val;\n    }\n    for (let jdx = 0; jdx < 0x100; jdx++) {\n        val = DETRANS62[_readNext() - 0x80] ^ last;\n        data[jdx] = val;\n        last = val;\n    }\n    const checkSum = DETRANS62[_readNext() - 0x80] ^ last;\n    if (checkSum) {\n        throw new InvalidChecksum(last, checkSum ^ last);\n    }\n    for (let kdx = 0, jdx = 0x55; kdx < 0x100; kdx++) {\n        data[kdx] <<= 1;\n        if ((data2[jdx] & 0x01) !== 0) {\n            data[kdx] |= 0x01;\n        }\n        data2[jdx] >>= 1;\n\n        data[kdx] <<= 1;\n        if ((data2[jdx] & 0x01) !== 0) {\n            data[kdx] |= 0x01;\n        }\n        data2[jdx] >>= 1;\n\n        if (--jdx < 0) jdx = 0x55;\n    }\n    return data;\n}\n\nfunction readSector13(_readNext: () => byte) {\n    const data = new Uint8Array(256);\n    let val: byte;\n    let last: byte = 0;\n\n    // special low 3-bits of 0xFF\n    val = DETRANS53[_readNext() - 0xA0] ^ last;\n    last = val;\n    data[0xff] = val & 0b111;\n\n    // expect 0x99 nibbles of packed lower 3-bits in reverse order\n    for (let i = 0x98; i >= 0x00; i--) {\n        val = DETRANS53[_readNext() - 0xA0] ^ last;\n        last = val;\n        const off = Math.floor(i / 0x33) + 5 * (0x32 - (i % 0x33));\n        const dOff = 3 + 5 * (0x32 - (i % 0x33));\n        const eOff = 4 + 5 * (0x32 - (i % 0x33));\n        const bit = 2 - Math.floor(i / 0x33);\n        data[off] = (val & 0b11100) >> 2;\n        data[dOff] ^= ((val & 0b00010) >> 1) << bit;\n        data[eOff] ^= (val & 0b1) << bit;\n    }\n\n    // expect 0xFE nibbles of upper 5-bits\n    for (let i = 0; i < 0xFF; i++) {\n        val = DETRANS53[_readNext() - 0xA0] ^ last;\n        last = val;\n        const off = Math.floor(i / 0x33) + 5 * (0x32 - (i % 0x33));\n        data[off] ^= val << 3;\n    }\n\n    // and the last special nibble for 0xFF\n    val = DETRANS53[_readNext() - 0xA0] ^ last;\n    last = val;\n    data[0xFF] ^= val << 3;\n\n    const checkSum = DETRANS53[_readNext() - 0xA0] ^ last;\n    if (checkSum) {\n        throw new InvalidChecksum(last, checkSum ^ last);\n    }\n    return data;\n}\n\n/**\n * Reads a sector of data from a nibblized disk\n *\n * TODO(flan): Does not work on WOZ disks\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns An array of sector data bytes.\n */\nexport function writeSector(disk: NibbleDisk, track: byte, sector: byte, _data: Uint8Array): boolean {\n    const trackNibble = findSector(disk, track, sector);\n    if (!trackNibble) {\n        return false;\n    }\n\n    // Todo\n\n    return true;\n}\n\n/**\n * Convert a nibblized disk into a JSON string for storage.\n *\n * @param disk Nibblized disk\n * @param pretty Whether to format the output string\n * @returns A JSON string representing the disk\n */\nexport function jsonEncode(disk: NibbleDisk, pretty: boolean): string {\n    // For 'nib', tracks are encoded as strings. For all other formats,\n    // tracks are arrays of sectors which are encoded as strings.\n    const data: string[] | string[][] = [];\n    let format = 'dsk';\n    for (let t = 0; t < disk.tracks.length; t++) {\n        data[t] = [];\n        if (disk.format === 'nib') {\n            format = 'nib';\n            data[t] = base64_encode(disk.tracks[t]);\n        } else {\n            for (let s = 0; s < 0x10; s++) {\n                const _sector = disk.format === 'po' ? _PO[s] : _DO[s];\n                (data[t] as string[])[s] = base64_encode(readSector(disk, t, _sector));\n            }\n        }\n    }\n    return JSON.stringify({\n        'type': format,\n        'encoding': 'base64',\n        'volume': disk.volume,\n        'data': data,\n        'readOnly': disk.readOnly,\n    }, undefined, pretty ? '    ' : undefined);\n}\n\n/**\n * Convert a JSON string into a nibblized disk.\n *\n * @param data JSON string representing a disk image, created by [jsonEncode].\n * @returns A nibblized disk\n */\n\nexport function jsonDecode(data: string): NibbleDisk {\n    const tracks: memory[] = [];\n    const json = JSON.parse(data) as JSONDisk;\n    const v = json.volume || 254;\n    const readOnly = json.readOnly || false;\n    for (let t = 0; t < json.data.length; t++) {\n        let track: byte[] = [];\n        for (let s = 0; s < json.data[t].length; s++) {\n            const _s = json.type === 'po' ? PO[s] : DO[s];\n            const sector: string = json.data[t][_s] as string;\n            const d = base64_decode(sector);\n            track = track.concat(explodeSector16(v, t, s, d));\n        }\n        tracks[t] = bytify(track);\n    }\n    if (!isNibbleDiskFormat(json.type)) {\n        throw new Error(`JSON disks of type ${json.type} are not supported`);\n    }\n    const disk: NibbleDisk = {\n        volume: v,\n        format: json.type,\n        encoding: ENCODING_NIBBLE,\n        metadata: { name: json.name },\n        tracks,\n        readOnly,\n    };\n\n    return disk;\n}\n\n/**\n * Debugging method that displays the logical sector ordering of a nibblized disk\n *\n * @param disk\n */\n\nexport function analyseDisk(disk: NibbleDisk) {\n    for (let track = 0; track < disk.tracks.length; track++) {\n        let outStr = `${toHex(track)}: `;\n        let val, state = 0;\n        let idx = 0;\n        const cur = disk.tracks[track];\n\n        const _readNext = () => {\n            const result = cur[idx++];\n            return result;\n        };\n\n        const _skipBytes = (count: number) => {\n            idx += count;\n        };\n\n        let t = 0, s = 0, v = 0, checkSum;\n        while (idx < cur.length) {\n            switch (state) {\n                case 0:\n                    val = _readNext();\n                    state = (val === 0xd5) ? 1 : 0;\n                    break;\n                case 1:\n                    val = _readNext();\n                    state = (val === 0xaa) ? 2 : 0;\n                    break;\n                case 2:\n                    val = _readNext();\n                    state = (val === 0x96) ? 3 : (val === 0xad ? 4 : 0);\n                    break;\n                case 3: // Address\n                    v = defourXfour(_readNext(), _readNext()); // Volume\n                    t = defourXfour(_readNext(), _readNext());\n                    s = defourXfour(_readNext(), _readNext());\n                    checkSum = defourXfour(_readNext(), _readNext());\n                    if (checkSum !== (v ^ t ^ s)) {\n                        debug('Invalid header checksum:', toHex(v), toHex(t), toHex(s), toHex(checkSum));\n                    } else {\n                        outStr += toHex(s, 1);\n                    }\n                    _skipBytes(3); // Skip footer\n                    state = 0;\n                    break;\n                case 4: // Valid header\n                    _skipBytes(0x159); // Skip data, checksum and footer\n                    state = 0;\n                    break;\n                default:\n                    break;\n            }\n        }\n        debug(outStr);\n    }\n}\n\n/**\n * Debugging utility to convert a bitstream into a nibble. Does not wrap.\n *\n * @param bits Bitstream containing nibbles\n * @param offset Offset into bitstream to start nibblizing\n * @returns nibble, the next nibble in the bitstream,\n *      and offset, the end of that nibble in the bitstream\n */\n\nexport function grabNibble(bits: bit[], offset: number) {\n    let nibble = 0;\n    let waitForOne = true;\n\n    while (offset < bits.length) {\n        const bit = bits[offset];\n        if (bit) {\n            nibble = (nibble << 1) | 0x01;\n            waitForOne = false;\n        } else {\n            if (!waitForOne) {\n                nibble = nibble << 1;\n            }\n        }\n        if (nibble & 0x80) {\n            // nibble complete return it\n            break;\n        }\n        offset += 1;\n    }\n\n    return {\n        nibble: nibble,\n        offset: offset\n    };\n}\n","import { explodeSector16, DO } from './format_utils';\nimport { bytify } from '../util';\nimport { byte } from '../types';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'dsk',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume,\n        readOnly,\n        tracks: [],\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: byte[] = [];\n        for (let physical_sector = 0; physical_sector < 16; physical_sector++) {\n            const dos_sector = DO[physical_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (16 * t + dos_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = new Uint8Array(data[t][dos_sector]);\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector16(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks[t] = bytify(track);\n    }\n    return disk;\n}\n","import { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\nimport { memory } from '../types';\n\n/**\n * Returns a `Disk` object from raw nibble image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromNibble(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'nib',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume: volume || 254,\n        readOnly: readOnly || false,\n        tracks: []\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: memory;\n        if (rawData) {\n            const off = t * 0x1a00;\n            track = new Uint8Array(rawData.slice(off, off + 0x1a00));\n        } else if (data) {\n            track = data[t][0];\n        } else {\n            throw new Error('Requires data or rawData');\n        }\n        disk.tracks[t] = track;\n    }\n\n    return disk;\n}\n","import { explodeSector16, PO } from './format_utils';\nimport { bytify } from '../util';\nimport type { byte } from '../types';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from ProDOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromProDOS(options: DiskOptions) {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'po',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume: volume || 254,\n        tracks: [],\n        readOnly: readOnly || false,\n    };\n\n    for (let physical_track = 0; physical_track < 35; physical_track++) {\n        let track: byte[] = [];\n        for (let physical_sector = 0; physical_sector < 16; physical_sector++) {\n            const prodos_sector = PO[physical_sector];\n            let sector;\n            if (rawData) {\n                const off = (16 * physical_track + prodos_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = data[physical_track][prodos_sector];\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector16(volume, physical_track, physical_sector, sector)\n            );\n        }\n        disk.tracks[physical_track] = bytify(track);\n    }\n\n    return disk;\n}\n","import DOS from './do';\nimport Nibble from './nib';\nimport ProDOS from './po';\nimport { BlockDisk, DiskOptions } from './types';\n\nimport { byte, ReadonlyUint8Array } from 'js/types';\n\n/**\n * Offsets in bytes to the various header fields. All number fields are\n * in little-endian order (least significant byte first). These values\n * come from the spec at:\n *\n * https://apple2.org.za/gswv/a2zine/Docs/DiskImage_2MG_Info.txt\n */\nconst OFFSETS = {\n    /** File signature ('2IMG', 4 bytes) */\n    SIGNATURE: 0x00,\n    /** Creator ID (4 bytes) */\n    CREATOR: 0x04,\n    /** Header length (2 bytes) */\n    HEADER_LENGTH: 0x08,\n    /** Version number (2 bytes). (Version of what? Format? Image?). */\n    VERSION: 0x0A,\n    /** Image format ID (4 bytes) */\n    FORMAT: 0x0C,\n    /** Flags and DOS 3.3 volume number */\n    FLAGS: 0x10,\n    /**\n     * Number of ProDOS blocks (4 bytes). ProDOS blocks are 512 bytes each.\n     * This field must be zero if the image format is not 0x01 (ProDOS).\n     * (ASIMOV2 always fills in this field.)\n     */\n    BLOCKS: 0x14,\n    /**\n     * Disk data start in bytes from the beginning of the image file\n     * (4 bytes).\n     */\n    DATA_OFFSET: 0x18,\n    /**\n     * Length of disk data in bytes (4 bytes). (143,360 bytes for 5.25\"\n     * floppies; 512 × blocks for ProDOS volumes.)\n     */\n    DATA_LENGTH: 0x1C,\n    /**\n     * Comment start in bytes from the beginning of the image file (4 bytes).\n     * Must be zero if there is no comment. The comment must come after the\n     * disk data and before the creator data. The comment should be \"raw text\"\n     * with no terminating null. By \"raw text\", we assume UTF-8.\n     */\n    COMMENT: 0x20,\n    /**\n     * Comment length in bytes (4 bytes). Must be zero if there is no comment.\n     */\n    COMMENT_LENGTH: 0x24,\n    /**\n     * Optional creator data start in bytes from the beginning of the image\n     * file (4 bytes). Must be zero if there is no creator data.\n     */\n    CREATOR_DATA: 0x28,\n    /**\n     * Creator data length in bytes (4 bytes). Must be zero if there is no\n     * creator data.\n     */\n    CREATOR_DATA_LENGTH: 0x2C,\n    /** Padding (16 bytes). Must be zero. */\n    PADDING: 0x30,\n} as const;\n\nconst FLAGS = {\n    READ_ONLY:    0x80000000,\n    VOLUME_VALID: 0x00000100,\n    VOLUME_MASK:  0x000000FF\n} as const;\n\nexport enum FORMAT {\n    DOS = 0,\n    ProDOS = 1,\n    NIB = 2,\n}\n\nexport interface HeaderData {\n    bytes: number;\n    creator: string;\n    format: FORMAT;\n    offset: number;\n    readOnly: boolean;\n    volume: byte;\n    comment?: string;\n    creatorData?: ReadonlyUint8Array;\n}\n\nexport function read2MGHeader(rawData: ArrayBuffer): HeaderData {\n    const prefix = new DataView(rawData);\n    const decoder = new TextDecoder('ascii');\n    const signature = decoder.decode(rawData.slice(OFFSETS.SIGNATURE, OFFSETS.SIGNATURE + 4));\n    if (signature !== '2IMG') {\n        throw new Error(`Unrecognized 2mg signature: ${signature}`);\n    }\n    const creator = decoder.decode(rawData.slice(OFFSETS.CREATOR, OFFSETS.CREATOR + 4));\n    const headerLength = prefix.getInt16(OFFSETS.HEADER_LENGTH, true);\n    if (headerLength !== 64) {\n        throw new Error(`2mg header length is incorrect ${headerLength} !== 64`);\n    }\n    const format = prefix.getInt32(OFFSETS.FORMAT, true);\n    const flags = prefix.getInt32(OFFSETS.FLAGS, true);\n    const blocks = prefix.getInt32(OFFSETS.BLOCKS, true);\n    const offset = prefix.getInt32(OFFSETS.DATA_OFFSET, true);\n    const bytes = prefix.getInt32(OFFSETS.DATA_LENGTH, true);\n    const commentOffset = prefix.getInt32(OFFSETS.COMMENT, true);\n    const commentLength = prefix.getInt32(OFFSETS.COMMENT_LENGTH, true);\n    const creatorDataOffset = prefix.getInt32(OFFSETS.CREATOR_DATA, true);\n    const creatorDataLength = prefix.getInt32(OFFSETS.CREATOR_DATA_LENGTH, true);\n\n    // Though the spec says that it should be zero if the format is not\n    // ProDOS, we don't check that since we know that it is violated.\n    // However we do check that it's correct if the image _is_ ProDOS.\n    if (format === FORMAT.ProDOS && blocks * 512 !== bytes) {\n        throw new Error(`2mg blocks does not match disk data length: ${blocks} * 512 !== ${bytes}`);\n    }\n    if (offset < headerLength) {\n        throw new Error(`2mg data offset is less than header length: ${offset} < ${headerLength}`);\n    }\n    if (offset + bytes > prefix.byteLength) {\n        throw new Error(`2mg data extends beyond disk image: ${offset} + ${bytes} > ${prefix.byteLength}`);\n    }\n    const dataEnd = offset + bytes;\n    if (commentOffset && commentOffset < dataEnd) {\n        throw new Error(`2mg comment is before the end of the disk data: ${commentOffset} < ${offset} + ${bytes}`);\n    }\n    const commentEnd = commentOffset ? commentOffset + commentLength : dataEnd;\n    if (commentEnd > prefix.byteLength) {\n        throw new Error(`2mg comment extends beyond disk image: ${commentEnd} > ${prefix.byteLength}`);\n    }\n    if (creatorDataOffset && creatorDataOffset < commentEnd) {\n        throw new Error(`2mg creator data is before the end of the comment: ${creatorDataOffset} < ${commentEnd}`);\n    }\n    const creatorDataEnd = creatorDataOffset ? creatorDataOffset + creatorDataLength : commentEnd;\n    if (creatorDataEnd > prefix.byteLength) {\n        throw new Error(`2mg creator data extends beyond disk image: ${creatorDataEnd} > ${prefix.byteLength}`);\n    }\n\n    const extras: { comment?: string; creatorData?: ReadonlyUint8Array } = {};\n    if (commentOffset) {\n        extras.comment = new TextDecoder('utf-8').decode(\n            new Uint8Array(rawData, commentOffset, commentLength));\n    }\n    if (creatorDataOffset) {\n        extras.creatorData = new Uint8Array(rawData, creatorDataOffset, creatorDataLength);\n    }\n\n    const readOnly = (flags & FLAGS.READ_ONLY) !== 0;\n    let volume = format === FORMAT.DOS ? 254 : 0;\n    if (flags & FLAGS.VOLUME_VALID) {\n        volume = flags & FLAGS.VOLUME_MASK;\n    }\n\n    return {\n        bytes,\n        creator,\n        format,\n        offset,\n        readOnly,\n        volume,\n        ...extras\n    };\n}\n\n/**\n * Creates the prefix and suffix parts of a 2mg file. Will use\n * default header values if headerData is null.\n *\n * Currently only supports blocks disks but should be adaptable\n * for nibble formats.\n *\n * @param headerData 2mg header data\n * @param blocks The number of blocks in a block volume\n * @returns 2mg prefix and suffix for creating a 2mg disk image\n */\n\nexport const create2MGFragments = (headerData: HeaderData | null, { blocks } : { blocks: number }) => {\n    if (!headerData) {\n        headerData = {\n            bytes: blocks * 512,\n            creator: 'A2JS',\n            format: FORMAT.ProDOS,\n            offset: 64,\n            readOnly: false,\n            volume: 0,\n        };\n    }\n    if (headerData.format !== FORMAT.ProDOS) {\n        throw new Error('Nibble formats not supported yet');\n    }\n    if (headerData.bytes !== blocks * 512) {\n        throw new Error('Byte count does not match block count');\n    }\n    const prefix = new Uint8Array(64);\n    const prefixView = new DataView(prefix.buffer);\n\n    const volumeFlags = headerData.volume ? headerData.volume | FLAGS.VOLUME_VALID : 0;\n    const readOnlyFlag = headerData.readOnly ? FLAGS.READ_ONLY : 0;\n    const flags = volumeFlags | readOnlyFlag;\n    const prefixLength = prefix.length;\n    const dataLength = blocks * 512;\n\n    let commentOffset = 0;\n    let commentLength = 0;\n    let commentData = new Uint8Array(0);\n    if (headerData.comment) {\n        commentData = new TextEncoder().encode(headerData.comment);\n        commentOffset = prefixLength + dataLength;\n        commentLength = commentData.length;\n    }\n    let creatorDataOffset = 0;\n    let creatorDataLength = 0;\n    let creatorData = new Uint8Array(0);\n    if (headerData.creatorData) {\n        creatorData = new Uint8Array(headerData.creatorData);\n        creatorDataOffset = prefixLength + dataLength + commentLength;\n        creatorDataLength = headerData.creatorData.length;\n    }\n\n    const encoder = new TextEncoder();\n\n    prefix.set(encoder.encode('2IMG'), OFFSETS.SIGNATURE);\n    prefix.set(encoder.encode(headerData.creator.slice(0, 4)), OFFSETS.CREATOR);\n    prefixView.setInt32(OFFSETS.HEADER_LENGTH, 64, true);\n    prefixView.setInt16(OFFSETS.VERSION, 1, true);\n    prefixView.setInt32(OFFSETS.FORMAT, headerData.format, true);\n    prefixView.setInt32(OFFSETS.FLAGS, flags, true);\n    prefixView.setInt32(OFFSETS.BLOCKS, blocks, true);\n    prefixView.setInt32(OFFSETS.DATA_OFFSET, prefixLength, true);\n    prefixView.setInt32(OFFSETS.DATA_LENGTH, dataLength, true);\n    prefixView.setInt32(OFFSETS.COMMENT, commentOffset, true);\n    prefixView.setInt32(OFFSETS.COMMENT_LENGTH, commentLength, true);\n    prefixView.setInt32(OFFSETS.CREATOR_DATA, creatorDataOffset, true);\n    prefixView.setInt32(OFFSETS.CREATOR_DATA_LENGTH, creatorDataLength, true);\n\n    const suffix = new Uint8Array(commentLength + creatorDataLength);\n    suffix.set(commentData);\n    suffix.set(creatorData, commentLength);\n\n    return { prefix, suffix };\n};\n\n/**\n * Creates a 2MG image from stored 2MG header data and a block disk. Will use\n * default header values if headerData is null.\n *\n * @param headerData 2MG style header data\n * @param blocks Prodos volume blocks\n * @returns 2MS\n */\n\nexport const create2MGFromBlockDisk = (headerData: HeaderData | null, { blocks }: BlockDisk): ArrayBuffer => {\n    const { prefix, suffix } = create2MGFragments(headerData, { blocks: blocks.length });\n\n    const imageLength = prefix.length + blocks.length * 512 + suffix.length;\n    const byteArray = new Uint8Array(imageLength);\n    byteArray.set(prefix);\n    for (let idx = 0; idx < blocks.length; idx++) {\n        byteArray.set(blocks[idx], prefix.length + idx * 512);\n    }\n    byteArray.set(suffix, prefix.length + blocks.length * 512);\n\n    return byteArray.buffer;\n};\n\n/**\n * Returns a `Disk` object from a 2mg image.\n * @param options the disk image and options\n */\nexport default function createDiskFrom2MG(options: DiskOptions) {\n    let { rawData } = options;\n    let disk;\n\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n\n    const { bytes, format, offset, readOnly, volume } = read2MGHeader(rawData);\n    rawData = rawData.slice(offset, offset + bytes);\n    options = { ...options, rawData, readOnly, volume };\n\n    // Check image format.\n    // Sure, it's really 64 bits. But only 2 are actually used.\n    switch (format) {\n        case FORMAT.ProDOS: // PO\n            disk = ProDOS(options);\n            break;\n        case FORMAT.NIB: // NIB\n            disk = Nibble(options);\n            break;\n        case FORMAT.DOS: // dsk\n        default:  // Something hinky, assume 'dsk'\n            disk = DOS(options);\n            break;\n    }\n\n    return disk;\n}\n","import { debug, toHex } from '../util';\nimport { bit, byte, word } from '../types';\nimport { grabNibble } from './format_utils';\nimport { DiskOptions, ENCODING_BITSTREAM, WozDisk } from './types';\n\nconst WOZ_HEADER_START = 0;\nconst WOZ_HEADER_SIZE = 12;\n\nconst WOZ1_SIGNATURE = 0x315A4F57;\nconst WOZ2_SIGNATURE = 0x325A4F57;\nconst WOZ_INTEGRITY_CHECK = 0x0a0d0aff;\n\n/**\n * Converts a range of bytes from a DataView into an ASCII string\n *\n * @param data DataView containing string\n * @param start start index of string\n * @param end end index of string\n * @returns ASCII string\n */\nfunction stringFromBytes(data: DataView, start: number, end: number): string {\n    const byteArray = new Uint8Array(\n        data.buffer.slice(data.byteOffset + start, data.byteOffset + end)\n    );\n    return String.fromCharCode(...byteArray);\n}\n\nexport class InfoChunk {\n    version: byte;\n\n    // Version 1\n    diskType: byte;\n    writeProtected: byte;\n    synchronized: byte;\n    cleaned: byte;\n    creator: string;\n\n    // Version 2\n    sides: byte = 0;\n    bootSector: byte = 0;\n    bitTiming: byte = 0;\n    compatibleHardware: word = 0;\n    requiredRAM: word = 0;\n    largestTrack: word = 0;\n\n    constructor(data: DataView) {\n        this.version = data.getUint8(0);\n        this.diskType = data.getUint8(1);\n        this.writeProtected = data.getUint8(2);\n        this.synchronized = data.getUint8(3);\n        this.cleaned = data.getUint8(4);\n        this.creator = stringFromBytes(data, 5, 37);\n\n        if (this.version > 1) {\n            this.sides = data.getUint8(37);\n            this.bootSector = data.getUint8(38);\n            this.bitTiming = data.getUint8(39);\n            this.compatibleHardware = data.getUint16(40, true);\n            this.requiredRAM = data.getUint16(42, true);\n            this.largestTrack = data.getUint16(44, true);\n        }\n    }\n}\n\nexport class TMapChunk {\n    trackMap: byte[];\n\n    constructor(data: DataView) {\n        this.trackMap = [];\n\n        for (let idx = 0; idx < 160; idx++) {\n            this.trackMap.push(data.getUint8(idx));\n        }\n    }\n}\n\nconst WOZ_TRACK_SIZE = 6656;\nconst WOZ_TRACK_INFO_BITS = 6648;\n\nexport class TrksChunk {\n    rawTracks: Uint8Array[];\n    tracks: Uint8Array[];\n}\n\nexport class TrksChunk1 extends TrksChunk {\n    constructor(data: DataView) {\n        super();\n\n        this.rawTracks = [];\n        this.tracks = [];\n\n        for (let trackNo = 0, idx = 0; idx < data.byteLength; idx += WOZ_TRACK_SIZE, trackNo++) {\n            let track = [];\n            const rawTrack: bit[] = [];\n            const slice = data.buffer.slice(data.byteOffset + idx, data.byteOffset + idx + WOZ_TRACK_SIZE);\n            const trackData = new Uint8Array(slice);\n            const trackInfo = new DataView(slice);\n            const trackBitCount = trackInfo.getUint16(WOZ_TRACK_INFO_BITS, true);\n            for (let jdx = 0; jdx < trackBitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] = (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) { break; }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport interface Trk {\n    startBlock: word;\n    blockCount: word;\n    bitCount: number;\n}\n\nexport class TrksChunk2 extends TrksChunk {\n    trks: Trk[];\n\n    constructor (data: DataView) {\n        super();\n\n        let trackNo;\n        this.trks = [];\n        for (trackNo = 0; trackNo < 160; trackNo++) {\n            const startBlock = data.getUint16(trackNo * 8, true);\n            const blockCount = data.getUint16(trackNo * 8 + 2, true);\n            const bitCount = data.getUint32(trackNo * 8 + 4, true);\n            if (bitCount === 0) { break; }\n            this.trks.push({\n                startBlock: startBlock,\n                blockCount: blockCount,\n                bitCount: bitCount\n            });\n        }\n        this.tracks = [];\n        this.rawTracks = [];\n\n        const bits = data.buffer;\n        for (trackNo = 0; trackNo < this.trks.length; trackNo++) {\n            const trk = this.trks[trackNo];\n\n            let track = [];\n            const rawTrack: bit[] = [];\n            const start = trk.startBlock * 512;\n            const end = start + trk.blockCount * 512;\n            const slice = bits.slice(start, end);\n            const trackData = new Uint8Array(slice);\n            if (trackNo === 0) {\n                // debug(`First bytes: ${toHex(trackData[0])} ${toHex(trackData[1])} ${toHex(trackData[2])} ${toHex(trackData[3])}`);\n            }\n            for (let jdx = 0; jdx < trk.bitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] = (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) { break; }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport class MetaChunk  {\n    values: Record<string, string>;\n\n    constructor (data: DataView) {\n        const infoStr = stringFromBytes(data, 0, data.byteLength);\n        const parts = infoStr.split('\\n');\n        this.values = parts.reduce(function(acc: Record<string, string>, part) {\n            const subParts = part.split('\\t');\n            acc[subParts[0]] = subParts[1];\n            return acc;\n        }, {});\n    }\n}\n\ninterface Chunks {\n    [key: string]: unknown;\n    info?: InfoChunk;\n    tmap?: TMapChunk;\n    trks?: TrksChunk;\n    meta?: MetaChunk;\n}\n\n/**\n * Returns a `Disk` object from Woz image data.\n * @param options the disk image and options\n * @returns A bitstream disk\n */\nexport default function createDiskFromWoz(options: DiskOptions): WozDisk {\n    const { rawData } = options;\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n    const dv = new DataView(rawData, 0);\n    let dvOffset = 0;\n    let wozVersion;\n    const chunks: Chunks = {};\n\n    function readHeader() {\n        const wozSignature = dv.getUint32(WOZ_HEADER_START + 0, true);\n\n        switch (wozSignature) {\n            case WOZ1_SIGNATURE:\n                wozVersion = 1;\n                break;\n            case WOZ2_SIGNATURE:\n                wozVersion = 2;\n                break;\n            default:\n                return false;\n        }\n\n        if (dv.getUint32(WOZ_HEADER_START + 4, true) !== WOZ_INTEGRITY_CHECK) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function readChunk() {\n        if (dvOffset >= dv.byteLength) {\n            return null;\n        }\n\n        const type = dv.getUint32(dvOffset, true);\n        const size = dv.getUint32(dvOffset + 4, true);\n        const data = new DataView(dv.buffer, dvOffset + 8, size);\n        dvOffset += size + 8;\n\n        return {\n            type: type,\n            size: size,\n            data: data\n        };\n    }\n\n    if (readHeader()) {\n        dvOffset = WOZ_HEADER_SIZE;\n        let chunk = readChunk();\n        while (chunk) {\n            switch (chunk.type) {\n                case 0x4F464E49: // INFO\n                    chunks.info = new InfoChunk(chunk.data);\n                    break;\n                case 0x50414D54: // TMAP\n                    chunks.tmap = new TMapChunk(chunk.data);\n                    break;\n                case 0x534B5254: // TRKS\n                    if (wozVersion === 1) {\n                        chunks.trks = new TrksChunk1(chunk.data);\n                    } else {\n                        chunks.trks = new TrksChunk2(chunk.data);\n                    }\n                    break;\n                case 0x4154454D: // META\n                    chunks.meta = new MetaChunk(chunk.data);\n                    break;\n                case 0x54495257: // WRIT\n                // Ignore\n                    break;\n                default:\n                    debug('Unsupported chunk', toHex(chunk.type, 8));\n            }\n            chunk = readChunk();\n        }\n    } else {\n        debug('Invalid woz header');\n    }\n\n    // debug(chunks);\n\n    const { meta, tmap, trks, info } = chunks;\n\n    const disk: WozDisk = {\n        encoding: ENCODING_BITSTREAM,\n        format: 'woz',\n        trackMap: tmap?.trackMap || [],\n        rawTracks: trks?.rawTracks || [],\n        readOnly: true, //chunks.info.writeProtected === 1;\n        metadata: {\n            name: meta?.values['title'] || options.name,\n            side: meta?.values['side_name'] || meta?.values['side']\n        },\n        info\n    };\n\n    return disk;\n}\n","import { includes, memory } from '../types';\nimport { base64_decode } from '../base64';\nimport { BitstreamFormat, DiskOptions, FloppyDisk, FloppyFormat, JSONDisk, NibbleDisk, NibbleFormat, NIBBLE_FORMATS, WozDisk } from './types';\nimport createDiskFrom2MG from './2mg';\nimport createDiskFromD13 from './d13';\nimport createDiskFromDOS from './do';\nimport createDiskFromProDOS from './po';\nimport createDiskFromWoz from './woz';\nimport createDiskFromNibble from './nib';\n\n/** Creates a `NibbleDisk` from the given format and options. */\nexport function createDisk(fmt: NibbleFormat, options: DiskOptions): NibbleDisk | null;\n/** Creates a `WozDisk` from the given format and options. */\nexport function createDisk(fmt: BitstreamFormat, options: DiskOptions): WozDisk | null;\n/** Creates a `FloppyDisk` (either a `NibbleDisk` or a `WozDisk`) from the given format and options. */\nexport function createDisk(fmt: FloppyFormat, options: DiskOptions): FloppyDisk | null;\nexport function createDisk(fmt: FloppyFormat, options: DiskOptions): FloppyDisk | null {\n    let disk: FloppyDisk | null = null;\n\n    switch (fmt) {\n        case '2mg':\n            disk = createDiskFrom2MG(options);\n            break;\n        case 'd13':\n            disk = createDiskFromD13(options);\n            break;\n        case 'do':\n        case 'dsk':\n            disk = createDiskFromDOS(options);\n            break;\n        case 'nib':\n            disk = createDiskFromNibble(options);\n            break;\n        case 'po':\n            disk = createDiskFromProDOS(options);\n            break;\n        case 'woz':\n            disk = createDiskFromWoz(options);\n            break;\n    }\n\n    return disk;\n}\n\n/** Creates a NibbleDisk from JSON */\nexport function createDiskFromJsonDisk(disk: JSONDisk): NibbleDisk | null {\n    const fmt = disk.type;\n    const readOnly = disk.readOnly;\n    const name = disk.name;\n    const side = disk.disk;\n\n    if (includes(NIBBLE_FORMATS, fmt)) {\n        let trackData: memory[][];\n        if (disk.encoding === 'base64') {\n            trackData = [];\n            for (let t = 0; t < disk.data.length; t++) {\n                trackData[t] = [];\n                if (disk.type === 'nib') {\n                    trackData[t][0] = base64_decode(disk.data[t]);\n                } else {\n                    for (let s = 0; s < disk.data[t].length; s++) {\n                        trackData[t][s] = base64_decode(disk.data[t][s]);\n                    }\n                }\n            }\n        } else {\n            trackData = disk.data;\n        }\n\n        const volume = disk.volume || 0xfe;\n\n        const options = {\n            volume,\n            readOnly,\n            name,\n            side,\n            data: trackData\n        } as DiskOptions;\n\n        return createDisk(fmt, options);\n    } else {\n        return null;\n    }\n}\n\n","import { explodeSector13, D13O } from './format_utils';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS 3.2-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS13(options: DiskOptions) {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'd13',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume,\n        readOnly,\n        tracks: []\n    };\n\n    if (!data && !rawData) {\n        throw new Error('data or rawData required');\n    }\n\n    /*\n     * DOS 13-sector disks have the physical sectors skewed on the track. The skew\n     * between physical sectors is 10 (A), resulting in the following physical order:\n     *\n     *   0 A 7 4 1 B 8 5 2 C 9 6 3\n     *\n     * Note that because physical sector == logical sector, this works slightly\n     * differently from the DOS and ProDOS nibblizers.\n     */\n\n    for (let t = 0; t < 35; t++) {\n        let track: number[] = [];\n        for (let disk_sector = 0; disk_sector < 13; disk_sector++) {\n            const physical_sector = D13O[disk_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (13 * t + physical_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = data[t][physical_sector];\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector13(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks.push(new Uint8Array(track));\n    }\n\n    return disk;\n}\n","import { debug } from '../js/util';\nimport { jsonDecode } from '../js/formats/format_utils';\nimport {\n    createDisk,\n    createDiskFromJsonDisk,\n} from '../js/formats/create_disk';\nimport {\n    FormatWorkerMessage,\n    DiskProcessedResponse,\n    DISK_PROCESSED,\n    PROCESS_BINARY,\n    PROCESS_JSON_DISK,\n    PROCESS_JSON,\n    FloppyDisk,\n} from '../js/formats/types';\n\ndebug('Worker loaded');\n\naddEventListener('message', (message: MessageEvent<FormatWorkerMessage>) => {\n    debug('Worker started', message.type);\n    const data = message.data;\n    const { driveNo } = data.payload;\n    let disk: FloppyDisk | null = null;\n\n    switch (data.type) {\n        case PROCESS_BINARY: {\n            const { fmt, options } = data.payload;\n            disk = createDisk(fmt, options);\n        }\n            break;\n\n        case PROCESS_JSON_DISK: {\n            const { jsonDisk } = data.payload;\n            disk = createDiskFromJsonDisk(jsonDisk);\n        }\n            break;\n\n        case PROCESS_JSON: {\n            const { json } = data.payload;\n            disk = jsonDecode(json);\n        }\n            break;\n    }\n\n    const response: DiskProcessedResponse = {\n        type: DISK_PROCESSED,\n        payload: {\n            driveNo,\n            disk\n        }\n    };\n\n    self.postMessage(response);\n\n    debug('Worker complete', message.type);\n});\n","/**\n * Extracts the members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_VALUES = ['a', 'b', 1, 2] as const;\n * type SomeValues = MemberOf<typeof SOME_VALUES>; // 'a' | 'b' | 1 | 2\n */\nexport type MemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E> ? E : never;\n\n/**\n * Recursively extracts all members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_ARRAYS = [['a'],['b', 2], 3] as const;\n * type SomeArrayValues = DeepMemberOf<typeof SOME_ARRAYS>; // 'a' | 'b' | 2 | 3\n */\nexport type DeepMemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E>\n    ? (E extends ReadonlyArray<unknown> ? DeepMemberOf<E> : E)\n    : never;\n\n/**\n * Extracts the declared keys of a type by removing `string` and `number`.\n *\n * Cribbed from the interwebs:\n * https://github.com/microsoft/TypeScript/issues/25987#issuecomment-408339599\n */\nexport type KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : K\n} extends { [_ in keyof T]: infer U } ? U : never;\n\n/**\n * Extracts the declared values of a constant object.\n */\nexport type KnownValues<T> = T extends {\n    [_ in keyof T]: infer U } ? U : never;\n\n/**\n * Replacement for `includes` on constant types that is also a type assertion.\n *\n * @example\n * const SOME_VALUES = [1, 2, 'a'] as const;\n * let n: number = 1;\n * let r = includes(SOME_VALUES, n); // r === true, n is 1 | 2 | 'a'\n * n = 5;\n * r = includes(SOME_VALUES, n); // r === false, n is number\n */\nexport function includes<S extends T, T>(a: ReadonlyArray<S>, v: T): v is S {\n    return (a as ReadonlyArray<T>).includes(v);\n}\n\n/** A bit. */\nexport type bit = 0 | 1;\n\n/** A nibble. */\nexport type nibble =\n    0x0 | 0x1 | 0x2 | 0x3 | 0x4 | 0x5 | 0x6 | 0x7 |\n    0x8 | 0x9 | 0xa | 0xb | 0xc | 0xd | 0xe | 0xf;\n\n/** A byte (0..255). This is not enforced by the compiler. */\nexport type byte = number;\n\n/** A word (0..65535). This is not enforced by the compiler. */\nexport type word = number;\n\n/** A raw region of memory. */\nexport type memory = Uint8Array;\n\n/** A raw region of memory. */\nexport type rom = ReadonlyUint8Array;\n\nexport interface Memory {\n    /** Read a byte. */\n    read(page: byte, offset: byte): byte;\n    /** Write a byte. */\n    write(page: byte, offset: byte, value: byte): void;\n}\n\n/** A mapped region of memory. */\nexport interface MemoryPages extends Memory {\n    /** Start page. */\n    start(): byte;\n    /** End page, inclusive. */\n    end(): byte;\n}\n\n/* An interface card */\nexport interface Card<StateT = unknown> extends Memory, Restorable<StateT> {\n    /* Reset the card */\n    reset?(): void;\n\n    /* Draw card to canvas */\n    blit?(): ImageData | undefined;\n\n    /* Process period events */\n    tick?(): void;\n\n    /* Read or Write an I/O switch */\n    ioSwitch(off: byte, val?: byte): byte | undefined;\n}\n\nexport type TapeData = Array<[duration: number, high: boolean]>;\n\nexport interface Restorable<T = unknown> {\n    getState(): T;\n    setState(state: T): void;\n}\n\n// Read-only typed arrays for constants\nexport type TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\nexport interface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n// Readonly RGB color value\nexport type Color = readonly [r: byte, g: byte, b: byte];\n"],"names":["hex_digits","bytify","ary","Uint8Array","args","console","log","v","n","result","idx","B64","base64_decode","data","o1","o2","o3","h1","h2","h3","h4","bits","i","ac","tmp_arr","indexOf","charAt","length","ENCODING_NIBBLE","ENCODING_BITSTREAM","NIBBLE_FORMATS","DO","PO","D13O","TRANS53","TRANS62","fourXfour","val","xx","yy","explodeSector16","volume","track","sector","gap","buf","push","checksum","concat","nibbles","idx2","idx6","val6","val2","last","explodeSector13","jdx","a5","a3","b5","b3","c5","c3","d5","d3","e5","e3","LookingFor","FindSectorError","Error","constructor","e","super","toHex","message","String","InvalidChecksum","expected","received","ReadSectorError","grabNibble","offset","nibble","waitForOne","createDiskFromDOS","options","name","side","rawData","readOnly","disk","format","encoding","metadata","tracks","t","physical_sector","dos_sector","off","slice","createDiskFromNibble","createDiskFromProDOS","physical_track","prodos_sector","OFFSETS","SIGNATURE","CREATOR","HEADER_LENGTH","VERSION","FORMAT","FLAGS","BLOCKS","DATA_OFFSET","DATA_LENGTH","COMMENT","COMMENT_LENGTH","CREATOR_DATA","CREATOR_DATA_LENGTH","PADDING","READ_ONLY","VOLUME_VALID","VOLUME_MASK","WOZ_HEADER_START","WOZ_HEADER_SIZE","WOZ1_SIGNATURE","WOZ2_SIGNATURE","WOZ_INTEGRITY_CHECK","stringFromBytes","start","end","byteArray","buffer","byteOffset","fromCharCode","InfoChunk","sides","bootSector","bitTiming","compatibleHardware","requiredRAM","largestTrack","this","version","getUint8","diskType","writeProtected","synchronized","cleaned","creator","getUint16","TMapChunk","trackMap","TrksChunk","TrksChunk1","rawTracks","trackNo","byteLength","rawTrack","trackData","trackBitCount","DataView","byteIndex","bitIndex","TrksChunk2","trks","startBlock","blockCount","bitCount","getUint32","trk","MetaChunk","parts","split","values","reduce","acc","part","subParts","createDisk","fmt","bytes","prefix","decoder","TextDecoder","signature","decode","headerLength","getInt16","getInt32","flags","blocks","commentOffset","commentLength","creatorDataOffset","creatorDataLength","ProDOS","dataEnd","commentEnd","creatorDataEnd","extras","comment","creatorData","DOS","read2MGHeader","NIB","createDiskFrom2MG","disk_sector","dv","wozVersion","dvOffset","chunks","readChunk","type","size","readHeader","chunk","info","tmap","meta","createDiskFromWoz","addEventListener","driveNo","payload","jsonDisk","includes","s","createDiskFromJsonDisk","json","JSON","parse","_s","d","f","jsonDecode","response","self","postMessage"],"sourceRoot":""}